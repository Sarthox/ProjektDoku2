\newpage
\section{Implementierungsphase}
\label{implementierungsphase}
\begin{comment}
	In Implementierung verlagern
	
	Beim Speichern wird über mehrere anliegende Systeme ein Angebot in einer Datenbank gespeichert. Wichtig ist dabei die Session, welche von einem der Systeme generiert wird, realisiert als \ac{GUID}. Mithilfe dieser wird ein Angebot im XML-Format in einer Datenbank gespeichert und ist dadurch eindeutig identifizierbar.\\
	
	Dies beinhaltet die gleiche Logik wie die Angebotsspeicherung, bis auf dass eine neue \ac{GUID} erzeugt wird, wodurch dementsprechend ein neuer Eintrag in der Datenbank und im Maklerportal hinterlegt wird. Außerdem muss mit der \ac{GUID}, bzw. Session der Kopie weitergearbeitet werden.\\
\end{comment} 

\subsection{Implementierung der Datenstruktur}
\label{datenstruktur}

\subsection{Implementierung der Benutzeroberfläche}
\label{oberflacheimplemetieren}
Die Benutzeroberfläche wird mit \gls{vue}, \gls{vuetify} und \gls{typescript} realisiert. Außerdem gibt es eine interne Komponentenbibliothek als \gls{npm}-Paket, welche Vuetify-Elemente kapselt und im Corporate Design und mit geringfügiger aber erweiterbarer Funktionalität anbietet. \gls{vue} großer Vorteil ist es, dass es die Oberfläche reaktiv macht. Das bedeutet, dass wenn sich Daten die mit einem Oberflächenelement verbunden sind ändern, wird dieses Element automatisch aktualisiert. Dies geschieht über das Observer-Designpattern. \gls{vuetify}, bzw. die Komponentenbibliothek hilft bei einem einheitlichem Design und erleichtert die Einbindung. Die durch \gls{typescript} bereit gestellte Typsicherheit macht das Arbeiten im Team, das Benutzen von Bibliotheken, vorausgesetzt diese haben Typescriptdatentypen deklariert sowie die Wartung und zukünfitge Erweiterungen einfacher.\\
Für die Zustandsverwaltung der Daten im Frontend wird der \gls{pinia} benutzt, eine Erweiterung des \gls{vue}-Stores. Dieser ist typsicher, was das Arbeiten mit Typescript erleichtert. Allgemein können mit so einem Store die Daten Komponenten übergreifend einheitlich gespeichert werden. In dem \ac{OTR} werden dort wichtige Daten welche das Backend bei der Initialisierung liefert gespeichert. Dazu gehören unter anderem Konfigurationen wie der \ac{OTR} aufgebaut werden soll welche Eingabemöglichkeiten gegeben sind und eventuelle Sitzungsdaten, wenn eine bestehende Sitzung geladen wurde. Außerdem werden berechnete Beiträge sowie eingegebene Daten gespeichert. Alle eingegebenen Daten werden automatisch beim Speichern im Store gleichzeitig ans Backend geschickt. Es gibt mehrere Teilstores, einen allgemeingültigen Store, in welchen Daten gespeichert werden welche tarifunabhängig sind und ein Store für den jeweilig aktiven Tarif. Auf die Daten aus einer anderen Komponente zugreifen kann man mit sogenannten Gettermethoden, welche im Store definiert werden.\\
Eine weitere Funktion des Stores ist ein Benachrichtigungssystem. Hierbei wird bei jeder Änderung von bestimmten Daten ein Ereignis losgetreten, so dass dann eine Benachrichtigung, z.B. ein Fehler oder eine Erfolgsnachricht bei einer Aktion, ausgegeben wird.\\

Als Fußzeilencontainer war die \textit{<footer>} Komponente von \gls{vuetify} gegeben. Die einzelnen Schaltflächen habe ich mit \textit{<km-button>} umgesetzt. Dieser ist in der besagten \ac{KM} Komponentenbibliothek gegeben. Eine Besonderheit ist hierbei der Button für den Dokumentenversand. Da der Dokumentenversand relativ viel Eigenlogik benötigt und schon in einer vorherigen \ac{OTR} Generation vorhanden war, gibt es diesen als eigenes \gls{npm}-Paket. Im Endeffekt wird in dieser Komponente allerdings auch nur der \textit{<km-button>} verwendet.\\

Die Angebot- bzw. Kopiespeichern-Schaltfläche soll nur vorhanden sein, wenn der \ac{OTR} über das Maklerportal aufgerufen wurde. Für so etwas bietet \gls{vue} ein konditionales Rendering als \gls{HTML}-Attribut an. Im \gls{pinia} wird überprüft, ob das Angebot speicherbar sein soll und dieser Wert wird an das Attribut übergeben. Beim Drücken auf den Knopf wird ein \gls{fetch} Aufruf ans Backend an den Management-Controller an die SaveOrder bzw SaveOrderCopy Action \marginline{Zu Spezifisch mit den Namen?} gemacht. Dieser ist durch automatisch generierte Klassen anhand der Schnittstellendefinition des Backends gekapselt. Diese kümmern sich um Fehlerbehandlung anhand des \gls{HTTP}-Statuscodes, erwarten die Argumente als richtigen Datentyp und geben die Response als eigenen Datentyp zurück. Ein Angebot wird anhand einer \ac{GUID} gespeichert, welche die aktuelle Sitzung des \ac{OTR} repräsentiert. Außerdem wird die Identifikationsnummer des angemeldeten Maklers, bzw. Vertriebspartners benötigt. Dementsprechend werden diese Daten mit ans Backend übergeben. Dieses kann sich anhand der Session die Angebotsdaten aus dem Cache laden und diese dann an das \ac{TRG} zum Speichern weiterschicken. Auf der Seite des Frontends passiert beim Kopiespeichern das Gleiche wie bei der normalen Speicherung, außer dass ein anderer Endpunkt aufgerufen wird.\\

Die Angebot- und Antragdruck-Schaltflächen sind zwar immer vorhanden, sind allerdings nicht immer aktiviert, bzw. benutzbar. Diese Logik setzt sich aus zwei Bedingungen zusammen. Zum einem muss überhaupt für den aktuellen Tarif der Antrags- bzw. Angebotsdruck aktiviert sein. Zum anderen ist das Drucken erst möglich, wenn ein Beitrag berechnet werden konnte. Diese Bedingungen werden im \gls{pinia} überprüft und in den Schaltfächenkomponenten in dem disabled-Attribut benutzt. Beim Drücken der Buttons wird ein Backend Aufruf an die Drucklogik gestartet. Dieser erwartet die Sessionguid, damit sich das Backend die benötigten Daten aus dem Cache laden kann. Zurückgeliefert wird ein PDF-Dokument als Filestream \marginline{Prüfen wie genau?}. Das wird dann im Frontend aufbereitet, so dass automatisch ein PDF-Dokument heruntergeladen wird. Da die Logik hierbei im Frontend zwischen dem Antrag und Angebot sich nur im aufgerufenem Endpunkt unterscheidet, ist die Logik zusammengefasst und der Aufruf des Backends kann als Action per Parameter reingegeben werden.\\
In die Fußzeile kommt außerdem noch das Impressum und das Copyright. Das Impressum ist hierbei eine Verlinkung auf das Impressum der Homepage von \ac{KM}.
\subsection{Implementierung der Geschäftslogik}
\label{geschaeftslogikimplementieren}
Die Geschäftslogik, bzw. das Backend ist eine \gls{net} \gls{api}. Als Programmiersprache wird dementsprechend C# 10 benutzt. Das Backend persistiert Daten in einem Storage oder Cache. \marginline{writer lock,cache,storage, repository pattern} Da die Kommunikation zwischen dem Backend und den anliegenden Systemen größtenteils über XML läuft, werden die gegebenen XML-Schemata eingelesen und beim Bauen des Backends als C# Klassen generiert. Dadurch können die Daten einheitlich und einfach geparst und ausgelesen werden. Allerdings kann es trotzdem vorkommen, dass Daten in anderen Datentypen verarbeitert werden. Um diese dann in das besagte XML-Format zu stecken \marginline{besser formulieren} wird ein \gls{automapper} genutzt, welchen man nur konfigurieren muss um die Daten in der jeweils andere Klasse speichern zu können.\\

Das Backend ist im \ac{ddd} -Pattern aufgebaut. Dementsprechend gibt es mehrere Services, welche jeweils in mehrere Projekte aufgeteilt sind. Unter anderem gibt es im Backend Schnittstellen für Anträge, Beitragsberechnung, Tarifkonfigurationen und allgemeine Logik unter Management. Jede dieser Schnittstellen haben nach dem \ac{ddd} ein eigenes Projekt für die eigentliche Schnittstelle, für die Infrastruktur und für die Logik. Außerdem wird die Logik für die verschiedenen Versicherungstarife aufgeteilt, da sie sich dort unterscheiden kann. Die unterschiedliche Logik der Tarife wird nach Strategy Pattern dynamisch je nach aktivem Tarif benutzt und per Dependency Injection Pattern reingegeben. Für die Fußzeilenkomponente ist nur der Managementservice interessant, da dort allgemeingültige und tarifunspezifische Logik zu finden ist.\\

Zum Speichern und Kopieren von Angeboten wird die Session als \ac{guid} benötigt. Anhand dieser Sessionguid, wird sich die Konfiguration und die gespeicherten Angebotsdaten aus dem Repositorycache geladen. Sowohl beim Speichern als auch beim Kopieren wird größtenteils die gleiche Logik benutzt. So wird bei beiden Varianten die Sessionspeicherungsschnittstelle des \ac{TRG}s aufgerufen, welches einen Eintrag in einer Datenbank hinterlegt oder falls schon einer mit dieser Sessionguid vorhanden ist, bearbeitet. Anschließend wird das Angebot im Repositorystorage gespeichert. \\ Die Besonderheit bei der Kopie ist, dass vor dem Aufruf ans \ac{TRG} eine neue \ac{guid} erzeugt wird. Dadurch wird ein neuer Eintrag in die Datenbank geschrieben. Außerdem muss das Angebot mit der neuen Sessionguid auch im Cache gespeichert werden. Die neue Sessionguid wird nun ans Frontend zurückgegeben, damit dort mit der Kopie weitergearbeitet wird.\\

