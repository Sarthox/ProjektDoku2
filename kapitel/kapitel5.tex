\section{Implementierungsphase}
\label{implementierungsphase}

\subsection{Implementierung der Datenstruktur}
\label{datenstruktur}
Die Datenstruktur wie in \ref{datenmodell} \nameref{datenmodell} beschrieben, war schon gegeben. Dementsprechend konnte der \gls{pinia} im Frontend sowie die Speicherung über die Repositorys im Backend für die Implementierung der Fußzeile genutzt werden.\\
Für den Store mussten einzelne Abfragen in Form von Gettermethoden implementiert werden, wie z.B. die Überprüfung ob ein Dokument druckbar ist. Die nötigen Funktionalitäten werden in \ref{oberflacheimplemetieren} \nameref{oberflacheimplemetieren} weiter aufgezeigt.
\subsection{Implementierung der Benutzeroberfläche und Frontendlogik}
\label{oberflacheimplemetieren}
Als Fußzeilencontainer war die \textit{<footer>} Komponente von \gls{vuetify} gegeben. Die einzelnen Schaltflächen wurden mit \textit{<km-button>} umgesetzt. Dieser ist in der besagten \ac{KM} Komponentenbibliothek gegeben. Eine Besonderheit ist hierbei die Schaltfläche für den Dokumentenversand. Da der Dokumentenversand relativ viel Eigenlogik benötigt und schon in einer vorherigen \ac{OTR} Generation vorhanden war, gibt es diesen als eigenes \gls{npm}-Paket. Im Endeffekt wird in dieser Komponente allerdings auch nur der \textit{<km-button>} verwendet. Die Einbindung des Pakets gestaltete sich aufgrund fehlender Dokumentation anspruchsvoller als angenommen.\\

Die Schaltfläche zur Speicherung von Angebot und Kopie soll nur vorhanden sein, wenn der \ac{OTR} über das Maklerportal aufgerufen wurde. Für so etwas bietet \gls{vue} ein konditionales Rendering als \gls{HTML}-Attribut an. Im \gls{pinia} wird überprüft, ob das Angebot speicherbar sein soll und dieser Wert wird an das Attribut übergeben. Beim Drücken auf die Schaltfläche wird ein \gls{fetch} Aufruf ans Backend gemacht. Anhand der Schnittstellenbeschreibung durch \gls{NSwag} wurde ein Client als Typescriptklasse generiert. Dieser kümmert sich um die Fehlerbehandlung anhand des \gls{HTTP}-Statuscodes, erwartet die Argumente als richtigen Datentyp und gibt den Response als eigenen Datentyp zurück. Ein Angebot wird anhand einer \ac{GUID} gespeichert, welche die aktuelle Sitzung des \ac{OTR}s repräsentiert. Außerdem wird die Identifikationsnummer des angemeldeten Maklers bzw. Vertriebspartners benötigt. Dementsprechend werden diese Daten mit an das Backend übergeben damit dieses sich anhand der Session die Angebotsdaten aus dem Cache laden und diese dann an das \ac{TRG} zum Speichern weiterschicken kann. Auf der Seite des Frontends geschieht bei der Kopiespeicherung das Gleiche wie bei der normalen Speicherung, außer dass ein anderer Endpunkt aufgerufen wird. Die Logik im Backend unterscheidet sich dabei von der Angebotsspeicherung.\\

Die Angebot- und Antragdrucken Schaltflächen sind zwar immer vorhanden, sind allerdings nicht immer aktiviert bzw. benutzbar. Diese Logik setzt sich aus zwei Bedingungen zusammen. Zum einem muss überhaupt für das aktuelle Produkt der Antrags- bzw. Angebotsdruck aktiviert sein. Zum anderen ist das Drucken erst möglich, wenn ein Beitrag berechnet werden konnte. Die notwendigen Daten werden aus dem \gls{pinia} geladen, überprüft und bestimmen in den Schaltflächenkomponenten ob sie aktiviert sind oder nicht. Beim Drücken der Schaltflächen wird ein Backend Aufruf an die Drucklogik gestartet. Dieser erwartet die Sessionguid, damit sich das Backend die benötigten Daten aus dem Speicher laden kann. Zurückgeliefert wird ein PDF-Dokument als Filestream. Das wird dann im Frontend aufbereitet, so dass automatisch ein PDF-Dokument heruntergeladen wird.\\
In die Fußzeile kommt dazu noch das Impressum und das Copyright. Das Impressum ist hierbei eine Verlinkung auf das Impressum der Homepage von \ac{KM}.
\subsection{Implementierung der Geschäftslogik}
\label{geschaeftslogikimplementieren}
Das Backend stellt mehrere Services bereit, gemäß \gls{ddd}. Diese sind in verschiedene Projekte aufgeteilt. Unter anderem gibt es im Backend Schnittstellen für Anträge, Beitragsberechnung, Tarifkonfigurationen und allgemeine Logik. Jede dieser Schnittstellen hat nach dem \gls{ddd} ein eigenes Projekt für die eigentliche Schnittstelle, für die Infrastruktur und für die Logik. Zusätzlich wird die Logik für die verschiedenen Versicherungstarife aufgeteilt, da die Produkte oder Versicherungstarife verschieden sind. Die unterschiedliche Logik der Tarife wird dynamisch je nach aktivem Tarif benutzt. Das wird durch \gls{di} ermöglicht. Für die Fußzeilenkomponente ist nur der Managementservice interessant, da dort allgemeingültige und tarifunspezifische Logik zu finden ist.\\

Zum Speichern und Kopieren von Angeboten wird die Session als \ac{GUID} benötigt. Anhand dieser Sessionguid, werden die Konfiguration und die gespeicherten Angebotsdaten aus dem Cache geladen. Sowohl beim Speichern als auch beim Kopieren wird größtenteils die gleiche Logik benutzt. So wird bei beiden Varianten die Sessionspeicherungsschnittstelle des \ac{TRG}s aufgerufen, welches einen Eintrag in einer Datenbank hinterlegt oder falls schon einer mit dieser Sessionguid vorhanden ist, bearbeitet. Anschließend wird das Angebot im Storage gespeichert. \\
Die Besonderheit bei der Kopie ist, dass vor dem Aufruf ans \ac{TRG} eine neue \ac{GUID} erzeugt wird. Dadurch wird ein neuer Eintrag in die Datenbank geschrieben. Außerdem muss das Angebot mit der neuen Sessionguid auch im Cache gespeichert werden. Die neue Sessionguid wird nun ans Frontend zurückgegeben, damit dort mit der Kopie weitergearbeitet wird.\\
Bei den Aufrufen für das Drucken von einem Angebot oder Antrag wird die Sessionguid und der Produkttyp, also welcher Tarif, benötigt. Hierbei wird der Pdftoolsservice aufgerufen, eine interne Schnittstelle die PDF-Dateien anhand eines Angebots bzw. Antrags als Stream liefert. Vorher muss allerdings, genau wie im Frontend, überprüft werden ob ein PDF überhaupt druckbar ist. Dafür werden die eingegebenen Daten validiert und eine Beitragsberechnung durchgeführt. Dieser Vorgang wird, obwohl diese Bedindungen im Frontend geprüft werden, nochmal Backendseitig vollzogen. Da Angebote und Anträge rechtlich bindend sind muss sichergestellt werden, dass diese Bedingungen erfüllt sind. Erst wenn die Überprüfung erfolgreich ist, wird ein PDF zurückgeliefert. Da diese Logik, bis auf den Aufruf vom Pdfservice identisch ist, wird der Pdfserviceaufruf per anonyme Funktion als Argument übergeben.\\
Die PDF-Dateien des Angebots und Antrags können zusätzlich per E-Mail versendet werden und aus diesem Grund benutzt die Dokumente-Versenden-Logik den gleichen Programmcode wie das Drucken. Wiederum können auch andere Dokumente versendet werden. Diese müssen beim Aufruf der Routine mit angegeben werden. Die Dokumente werden dann heruntergeladen und anschließend wird ein Aufruf an den Mailservice getätigt, welcher diese Dokumente an die angegebene E-Mail versendet.

