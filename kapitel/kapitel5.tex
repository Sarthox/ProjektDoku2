\newpage
\section{Implementierungsphase}
\label{implementierungsphase}
\begin{comment}
	In Implementierung verlagern
	
	Beim Speichern wird über mehrere anliegende Systeme ein Angebot in einer Datenbank gespeichert. Wichtig ist dabei die Session, welche von einem der Systeme generiert wird, realisiert als \ac{GUID}. Mithilfe dieser wird ein Angebot im XML-Format in einer Datenbank gespeichert und ist dadurch eindeutig identifizierbar.\\
	
	Dies beinhaltet die gleiche Logik wie die Angebotsspeicherung, bis auf dass eine neue \ac{GUID} erzeugt wird, wodurch dementsprechend ein neuer Eintrag in der Datenbank und im Maklerportal hinterlegt wird. Außerdem muss mit der \ac{GUID}, bzw. Session der Kopie weitergearbeitet werden.\\
	
	
	Hier könnte man den Pinia store erwähnen und die Werte, die die Buttons steuern, ob diese Sichtbar sind bzw. aktiv oder inaktiv.
\end{comment} 

\subsection{Implementierung der Datenstruktur}
\label{datenstruktur}

\subsection{Implementierung der Benutzeroberfläche}
\label{oberflacheimplemetieren}
%Diesen Abschnitt evtl in die Entwurfsphase???
Die Benutzeroberfläche wird mit \gls{vue}, \gls{vuetify} und \gls{typescript} realisiert. Außerdem gibt es eine interne Komponentenbibliothek als \gls{npm}-Paket, welche Vuetify-Elemente kapselt und im Corporate-Design mit geringfügiger aber erweiterbarer Funktionalität anbietet. \gls{vue} großer Vorteil ist es, dass die Oberfläche reaktiv gemacht wird. Das bedeutet, dass wenn sich Daten die mit einem Oberflächenelement verbunden sind ändern, wird dieses Element automatisch aktualisiert. Dies geschieht über das Observer-Designpattern. \gls{vuetify} bzw. die Komponentenbibliothek hilft bei einem einheitlichem Design und erleichtert die Einbindung durch bereitgestellten Vorlagen. Die durch \gls{typescript} bereit gestellte Typsicherheit macht das Arbeiten im Team einfacher. Das Benutzen von Bibliotheken, vorausgesetzt diese haben Typescriptdatentypen deklariert wird auch erleichtert. Außerdem gestaltet sich die Wartung und zukünftige Erweiterungen problemloser.\\
Für den \ac{OTR} wichtige Daten werden in dem in Kapitel 3 beschriebenem Store gespeichert. Die Fußzeilenkomponente greift hierbei auf die Konfiguration des \ac{OTR}s sowie die Sessionguid zu.
Eine weitere Funktion des Stores ist ein Benachrichtigungssystem. Hierbei wird bei jeder Änderung von bestimmten Daten ein Ereignis losgetreten, so dass dann eine Benachrichtigung, z.B. ein Fehler oder eine Erfolgsnachricht bei einer Aktion, ausgegeben wird.\\
%Abschnitt bis hier
Als Fußzeilencontainer war die \textit{<footer>} Komponente von \gls{vuetify} gegeben. Die einzelnen Schaltflächen habe ich mit \textit{<km-button>} umgesetzt. Dieser ist in der besagten \ac{KM} Komponentenbibliothek gegeben. Eine Besonderheit ist hierbei der Button für den Dokumentenversand. Da der Dokumentenversand relativ viel Eigenlogik benötigt und schon in einer vorherigen \ac{OTR} Generation vorhanden war, gibt es diesen als eigenes \gls{npm}-Paket. Im Endeffekt wird in dieser Komponente allerdings auch nur der \textit{<km-button>} verwendet. Die Einbindung des Pakets gestaltete sich aufgrund fehlender Dokumentation anspruchsvoller als angenommen.\\

Die Angebot- bzw. Kopiespeichern-Schaltfläche soll nur vorhanden sein, wenn der \ac{OTR} über das Maklerportal aufgerufen wurde. Für so etwas bietet \gls{vue} ein konditionales Rendering als \gls{HTML}-Attribut an. Im \gls{pinia} wird überprüft, ob das Angebot speicherbar sein soll und dieser Wert wird an das Attribut übergeben. Beim Drücken auf die Schaltfläche wird ein \gls{fetch} Aufruf ans Backend gemacht. Anhand der Schnittstellenbeschreibung durch \gls{NSwag} wurde ein Client als Typescriptklasse generiert. Dieser kümmert sich um die Fehlerbehandlung anhand des \gls{HTTP}-Statuscodes, erwartet die Argumente als richtigen Datentyp und gibt den Response als eigenen Datentyp zurück. Ein Angebot wird anhand einer \ac{GUID} gespeichert, welche die aktuelle Sitzung des \ac{OTR} repräsentiert. Außerdem wird die Identifikationsnummer des angemeldeten Maklers bzw. Vertriebspartners benötigt. Dementsprechend werden diese Daten mit ans Backend übergeben damit dieses sich anhand der Session die Angebotsdaten aus dem Cache laden und diese dann an das \ac{TRG} zum Speichern weiterschicken kann. Auf der Seite des Frontends passiert beim Kopiespeichern das Gleiche wie bei der normalen Speicherung, außer dass ein anderer Endpunkt aufgerufen wird. Die Logik im Backend unterscheidet sich dabei allerdings von der Angebotsspeicherung.\\

Die Angebot- und Antragdrucken Schaltflächen sind zwar immer vorhanden, sind allerdings nicht immer aktiviert bzw. benutzbar. Diese Logik setzt sich aus zwei Bedingungen zusammen. Zum einem muss überhaupt für das aktuelle Produkt der Antrags- bzw. Angebotsdruck aktiviert sein. Zum anderen ist das Drucken erst möglich, wenn ein Beitrag berechnet werden konnte. Die notwendigen Daten werden aus dem \gls{pinia} geladen, überprüft und bestimmen in den Schaltflächenkomponenten ob sie aktiviert sind oder nicht. Beim Drücken der Schaltflächen wird ein Backend Aufruf an die Drucklogik gestartet. Dieser erwartet die Sessionguid, damit sich das Backend die benötigten Daten aus dem Speicher laden kann. Zurückgeliefert wird ein PDF-Dokument als Filestream. Das wird dann im Frontend aufbereitet, so dass automatisch ein PDF-Dokument heruntergeladen wird.\\
In die Fußzeile kommt außerdem noch das Impressum und das Copyright. Das Impressum ist hierbei eine Verlinkung auf das Impressum der Homepage von \ac{KM}.
\subsection{Implementierung der Geschäftslogik}
\label{geschaeftslogikimplementieren}
Die Geschäftslogik bzw. das Backend ist eine \gls{net} \gls{api}. Als Programmiersprache wird dementsprechend C\# 10 benutzt. Das Backend persistiert Daten in einem Storage bzw. Cache. \marginline{writer lock,cache,storage, repository pattern} Da die Kommunikation zwischen dem Backend und den anliegenden Systemen größtenteils über XML läuft, können die vorhanden XML Schemata genutzt werden um geeignete C\# Klassen für das Backend zu generieren. Dadurch können die Daten einheitlich und einfach geparst und ausgelesen werden.\\

Das Backend stellt mehrere Services bereits, gemäß \gls{ddd}. Diese sind in verschiedene Projekte aufgeteilt. Unter anderem gibt es im Backend Schnittstellen für Anträge, Beitragsberechnung, Tarifkonfigurationen und allgemeine Logik. Jede dieser Schnittstellen hat nach dem \gls{ddd} ein eigenes Projekt für die eigentliche Schnittstelle, für die Infrastruktur und für die Logik. Außerdem wird die Logik für die verschiedenen Versicherungstarife aufgeteilt, da die Produkte oder Versicherungstarife verschieden sind. Die unterschiedliche Logik der Tarife wird dynamisch je nach aktivem Tarif benutzt. Das wird durch \gls{di} ermöglicht. Für die Fußzeilenkomponente ist nur der Managementservice interessant, da dort allgemeingültige und tarifunspezifische Logik zu finden ist.\\

Zum Speichern und Kopieren von Angeboten wird die Session als \ac{guid} benötigt. Anhand dieser Sessionguid, wird sich die Konfiguration und die gespeicherten Angebotsdaten aus dem Cache geladen. Sowohl beim Speichern als auch beim Kopieren wird größtenteils die gleiche Logik benutzt. So wird bei beiden Varianten die Sessionspeicherungsschnittstelle des \ac{TRG}s aufgerufen, welches einen Eintrag in einer Datenbank hinterlegt oder falls schon einer mit dieser Sessionguid vorhanden ist, bearbeitet. Anschließend wird das Angebot im Storage
%todo storage cache etc erklären
%todo texte dopplung entfernen
 gespeichert. \\ Die Besonderheit bei der Kopie ist, dass vor dem Aufruf ans \ac{TRG} eine neue \ac{guid} erzeugt wird. Dadurch wird ein neuer Eintrag in die Datenbank geschrieben. Außerdem muss das Angebot mit der neuen Sessionguid auch im Cache gespeichert werden. Die neue Sessionguid wird nun ans Frontend zurückgegeben, damit dort mit der Kopie weitergearbeitet wird.\\
Bei den Aufrufen für das Drucken von einem Angebot oder Antrag wird die Sessionguid und der Produkttyp, also welcher Tarif, benötigt. Hierbei wird der Pdftoolsservice aufgerufen, eine interne Schnittstelle die PDF-Dateien anhand eines Angebots bzw. Antrags als Stream liefert. Vorher muss allerdings, genau wie im Frontend, überprüft werden ob ein PDF überhaupt druckbar ist. Dafür werden die eingegebenen Daten validiert und eine Beitragsberechnung durchgeführt. Dieser Vorgang wird, obwohl diese Bedindungen im Frontend geprüft werden, nochmal Backendseitig vollzogen. Da Angebote und Anträge rechtlich binden sind muss sichergestellt werden, dass diese Bedingungen erfüllt sind. Erst wenn die Überprüfung erfolgreich ist, wird ein PDF zurückgeliefert. Da diese Logik, bis auf den Aufruf vom Pdfservice identisch ist, wird der Pdfserviceaufruf per anonyme Funktion als Argument reingegeben.\\
Da man sich genau diese PDF-Dateien auch per E-Mail zu senden kann, benutzt die Dokumente-Versenden-Logik den gleichen Programmcode wie das Drucken. Allerdings können auch andere Dokumente versendet werden. Diese müssen beim Aufruf der Action mit angegeben werden. Die Dokumente werden dann runter geladen und anschließend wird ein Aufruf an den Mailservice getätigt, welcher diese Dokumente an die angegebene E-Mail versendet.

