\newpage
\section{Entwurfsphase}
\label{entwurfsphase}
%Der \ac{OTR} ist schon lange in Entwurf und wurde 

\begin{comment}
	Die Kommunikation zwischen Front- und Backend wird durch REST-API Aufrufe realisiert. Um die Daten synchron zu halten wird jede Änderung im Frontend in den \gls{localstorage} des Browsers geschrieben und zeitgleich per HTTP-JSON-PATCH Aufruf ans Backend weitergesendet. Das Backend speichert die neuen oder geänderten Daten im Cache und führt wenn möglich eine Berechnung sowie Validierung durch. Die berechneten Beiträge und Validierungsergebnisse werden anschließend zurückgesendet. Alle Schnittstellen sowie \ac{DTO} werden beim Bauen des Backends automatisch für das Frontend generiert.\\
	Als Versionsverwaltung für dieses Projekt wird \gls{git} mit \gls{gitflow} genutzt. Das \ac{CICD} wird mittels \gls{gitlab} Pipelines realisiert, also eine Möglichkeit automatisch nach jeder Änderung das Projekt zu bauen, zu testen und zu veröffentlichen. Veröffentlicht wird der \ac{OTR} in einem \gls{k8s}-Cluster. Somit muss vorher ein Dockerimage gebaut werden um es dann in einem Container laufen zu lassen. Für jeden Feature-, Develop- und Masterbranch im Git wird jeweils eine eigene Instanz im \gls{k8s} Cluster erstellt, so dass man jeden Stand auf dem Testsystem testen kann.
	Für die Zustandsverwaltung der Daten im Frontend wird der \gls{pinia} benutzt. Dieser ist typsicher, was das Arbeiten mit Typescript erleichtert. Allgemein können mit so einem Store die Daten komponentenübergreifend einheitlich gespeichert werden. In dem \ac{OTR} werden dort wichtige Daten, welche das Backend bei der Initialisierung liefert, gespeichert. Dazu gehören unter anderem Konfigurationen, wie die Oberfläche des \ac{OTR}s aufgebaut werden soll, welche Eingabemöglichkeiten gegeben sind und eventuelle Sitzungsdaten, wenn eine bestehende Sitzung geladen wurde. Außerdem werden berechnete Beiträge sowie eingegebene Daten gespeichert. Alle eingegebenen Daten werden automatisch beim Speichern im Store gleichzeitig ans Backend geschickt. Auf die Daten aus einer anderen Komponente zugreifen kann man mit sogenannten Gettermethoden, welche im Store definiert werden.\\
\end{comment}
\subsection{Zielplattform}
\label{zielplattform}
Das gesamte Projekt soll in einem \gls{Container} innerhalb eines \gls{k8s} Cluster laufen. Demnach ist die Zielplattform eine Linuxdistribution. Durch \gls{k8s} besteht ein Loadbalancing um eine bessere Skalierbarkeit zu ermöglichen. Vorteile dieses Deployments ist außerdem, dass es mehrere Versionen und unterschiedliche Stages gibt die zeitgleich laufen. Dadurch ist die Anwendung besser testbar und neue Versionen können nahtlos veröffentlicht werden.
\subsection{Architekturdesign}
\label{architekturdesign}
Die Backend Architektur besteht aus Microservices nach dem \gls{ddd}-Pattern. Außerdem wird für die Datenpersistenz das \gls{repopattern} benutzt. Im Frontend werden Komponenten benutzt, welche ihre Daten über eine zentrale Datenzustandsverwaltung beziehen. Die Kommunikation zwischen Front- und Backend geschieht über \gls{REST}-Aufrufe. Daten aus dem Frontend werden per JSONPatch Protokoll über die HTTP-Patch-Methode übermittelt. Dadurch können Änderungen auch kleinteilig zwischen Front- und Backend synchronisiert und über das Backend persistiert werden.
\subsection{Entwurf der Benutzeroberfläche}
\label{benutzeroberfläche}
Der designseitige Entwurf der Benutzeroberfläche wurde durch die Marketing-Abteilung per Mockups übernommen. Diese mussten allerdings nicht eins zu eins umgesetzt werden, sondern konnten in Kombination mit den Corporate-Design-Vorlagen als Richtlinie genutzt werden. Außerdem gab es wöchentliche Absprache sowie Absprachen mit einem externen Dienstleister in denen speziell das Design abgestimmt wurde.
\subsection{Datenmodell}
\label{datenmodell}

\subsection{Geschäftslogik}
\label{geschaeftslogik}
Die Logik der Benutzeroberfläche und die technische Umsetzung wurde innerhalb des Entwicklerteams durch Prototyping erarbeitet.\\
Dadurch musste für die Fußzeilenkomponente speziell keine eigene Logik oder Design entworfen werden, es wurde anhand des Entwurfs für das Gesamtprojekt bearbeitet.
\subsection{Maßnahmen zur Qualitätssicherung}
\label{qualitaetssicherung}
Durch die Arbeit mit Gitflow wurde jede Unteraufgabe in einem eigenem Gitbranch bearbeitet. Diese Branches werden erst nach Codereviews vom Entwicklerteam in den develop-Branch überführt. Bei jedem Push werden per Gitlab Pipeline Unittests im Front- und Backend ausgeführt. Im Backend habe ich die bestehenden Unittests erweitert um neu implementierte Logik zu testen. Zu dem wurde im Frontend ein \gls{Linter} konfiguriert um einheitliche Codeguidelines und Codestyling durchzusetzen.\\
Wenn eine Änderung auf den Developbranch gepusht wurde wird diese von einem anderen Entwickler getestet. Außerdem gibt es weitere Mitarbeiter außerhalb des Entwicklerteams die regelmäßig auf dem Testsystem Blackbox-Akzeptanztests durchführen.