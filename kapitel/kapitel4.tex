\section{Entwurfsphase}
\label{entwurfsphase}
%Der \ac{OTR} ist schon lange in Entwurf und wurde 
\subsection{Zielplattform}
\label{zielplattform}
Das gesamte Projekt soll in einem \gls{Container} innerhalb eines \gls{k8s} Cluster laufen. Somit muss vorher ein Dockerimage gebaut werden um es dann in einem Container laufen zu lassen. Demnach ist die Zielplattform eine Linuxdistribution. Durch \gls{k8s} besteht ein Loadbalancing um eine bessere Skalierbarkeit zu ermöglichen. Vorteile dieses Deployments ist außerdem, dass es mehrere Versionen und unterschiedliche Stages gibt die zeitgleich laufen. Für jeden Feature-, Develop- und Masterbranch im Git wird jeweils eine eigene Instanz im \gls{k8s} Cluster erstellt, so dass man jeden Stand auf dem Testsystem testen kann. Dadurch ist die Anwendung besser testbar und neue Versionen können nahtlos veröffentlicht werden.
\subsection{Architekturdesign}
\label{architekturdesign}
Die Backend Architektur besteht aus Microservices nach dem \gls{ddd}-Pattern. Außerdem wird für die Datenpersistenz das \gls{repopattern} benutzt. Im Frontend werden Komponenten benutzt, welche ihre Daten über eine zentrale Datenzustandsverwaltung beziehen. Die Kommunikation zwischen Front- und Backend wird durch REST-API Aufrufe realisiert. Um die Daten synchron zu halten wird jede Änderung im Frontend in den \gls{localstorage} des Browsers geschrieben und zeitgleich per HTTP-JSON-PATCH Aufruf ans Backend weitergesendet. Das Backend speichert die neuen oder geänderten Daten im Cache und führt wenn möglich eine Berechnung sowie Validierung durch. Die berechneten Beiträge und Validierungsergebnisse werden anschließend zurückgesendet. Durch die generische JSON-Patch Methode können Änderungen auch kleinteilig in Form von Schlüssel-Wert-Paaren bestehend aus dem Pfad in der JSON Struktur und dem Wert zwischen Front- und Backend synchronisiert und über das Backend persistiert werden. Das Persistieren über das \gls{repopattern} wird eingehender in Abschnitt \ref{datenmodell} \nameref{datenmodell} erklärt.
\subsection{Entwurf der Benutzeroberfläche}
\label{benutzeroberfläche}
Der designseitige Entwurf der Benutzeroberfläche wurde durch die Marketing-Abteilung per Mockups übernommen. Diese mussten allerdings nicht eins zu eins umgesetzt werden, sondern konnten in Kombination mit den Corporate-Design-Vorlagen als Richtlinie genutzt werden. Außerdem gab es wöchentliche Absprachen in denen speziell das Design abgestimmt wurde. Dadurch musste weniger Zeit für die Entwicklung und Entwerfen der Oberfläche und Workflows von meiner Seite aus aufgebracht werden. Abbildungen eines Mockups und das finale Design der Fußzeilenkomponente sind jeweils im Anhang zu finden (s. A.\ref{mockup} \nameref{mockup}, A.\ref{actualfooter} \nameref{actualfooter})
\subsection{Entwurf der Datenstruktur}
\label{datenmodell}
Wie schon in \ref{architekturdesign} \nameref{architekturdesign} erwähnt wird das \gls{repopattern} angewendet um Daten zu persistieren. Dementsprechend gibt es verschiedene Repository-Klassen, welche den Datenzugriff kapseln. Der Datenzugriff ist hierbei zweistufig. Als erstes werden Daten, diese können z.B. zu gespeicherten Angeboten oder Tarifkonfigurationen sein, im Cache gespeichert. Dieser ist nur ein temporärer Speicher der die Daten für bis zu 6 Stunden im Arbeitsspeicher hält. Die zweite Stufe ist der \gls{distributedcache}, wird aber im Verlauf dieser Dokumentation Storage genannt. Der Storage speichert die Daten in einer Datenbank ab.
Wenn, wie in \ref{projektschnittstellen} \nameref{projektschnittstellen} dargestellt, Angebote über das Maklerportal gespeichert werden, werden die Daten fünf Jahre lang in der Datenbank persistiert. Eine andere Möglichkeit um Daten vom Cache in den Storage zu überführen ist durch den Aufruf der Shutdown-Action im Backend. Dabei werden die Daten einen Tag lang persistiert. Benutzt wird Shutdown z.B. wenn der \ac{OTR} neugestartet werden muss und die Daten dementsprechend aus dem Cache kurzzeitig gespeichert werden müssen damit diese nicht verloren gehen.\\
Bei einem Datenzugriff wird immer als erstes der Cache abgefragt und wenn die geforderten Daten dort nicht zu finden sind, in den Storage.\\
Für die Zustandsverwaltung der Daten im Frontend wird der \gls{pinia} benutzt. Dieser ist typsicher, was das Arbeiten mit Typescript erleichtert. Allgemein können mit so einem Store die Daten komponentenübergreifend einheitlich gespeichert werden. In dem \ac{OTR} werden dort wichtige Daten, welche das Backend bei der Initialisierung liefert, gespeichert. Dazu gehören unter anderem Konfigurationen, wie die Oberfläche des \ac{OTR}s aufgebaut werden soll, welche Eingabemöglichkeiten gegeben sind und eventuelle Sitzungsdaten, wenn eine bestehende Sitzung geladen wurde. Außerdem werden berechnete Beiträge sowie eingegebene Daten gespeichert. Auf die Daten aus einer anderen Komponente zugreifen kann man mit sogenannten Gettermethoden, welche im Store definiert werden.
\subsection{Entwurf der Geschäftslogik}
\label{geschaeftslogik}
Die Logik der Benutzeroberfläche und die technische Umsetzung wurde innerhalb des Entwicklerteams durch Prototyping erarbeitet.
Dadurch musste für die Fußzeilenkomponente speziell kein eigener Entwurf entstehen, es wurde anhand des Entwurfs für das Gesamtprojekt bearbeitet.\\
Wie schon in \ref{projektziel} \nameref{projektziel} beschrieben, wird die Oberfläche unter anderem mit \gls{vue} realisiert. \gls{vue} großer Vorteil ist es, dass die Oberfläche reaktiv gemacht wird. Das bedeutet, dass wenn sich Daten die mit einem Oberflächenelement verbunden sind ändern, wird dieses Element automatisch aktualisiert. Dies geschieht über das Observer-Designpattern.\\
Für den \ac{OTR} wichtige Daten werden in dem Store gespeichert. Die Fußzeilenkomponente greift hierbei auf die Konfiguration des \ac{OTR}s sowie die Sessionguid zu.
Eine weitere Funktion des Stores ist ein Benachrichtigungssystem. Hierbei wird bei jeder Änderung von bestimmten Daten ein Ereignis losgetreten, so dass dann eine Benachrichtigung, z.B. ein Fehler oder eine Erfolgsnachricht bei einer Aktion, ausgegeben wird.\\

Die Geschäftslogik bzw. das Backend ist eine \gls{net} \gls{api}. Als Programmiersprache wird dementsprechend C\# 10 benutzt.
Im Backend werden Datenhalterklassen anhand von XML Schemata automatisch generiert. Mit Hilfe von der Swagger OpenApi Dokumentation der Controller wird ein \gls{typescript} API-Client geschaffen. Genauso werden C\#-Clients für benutzte Schnittstellen, z.B. dem Dokumentenversandservice, erzeugt.\\
Für die einzelnen Controller der API bestehen Serviceklassen in welchen die Funktionalität bereitgestellt wird. So gibt es ein Interface welches die benötigten Methoden vorgibt und eine abstrakte Klasse welche alle tarifunabhängigen Methoden des Interfaces implementiert. Zu dem gibt es für jeden Tarif oder jedes Versicherungsprodukt eine Klasse, welche von der abstrakten Klasse erbt und das Interface implementiert. Dadurch kann im Controller dynamisch anhand vom jeweilig aktivem Tarif die passende Implementierung benutzt werden. %todo management service klassendiagramm zeige
Alle Abhängigkeiten werden per \gls{di} aufgelöst.
\subsection{Maßnahmen zur Qualitätssicherung}
\label{qualitaetssicherung}
Durch die Arbeit mit Gitflow wurde jede Unteraufgabe in einem eigenem Gitbranch bearbeitet. Diese Branches werden erst nach Codereviews vom Entwicklerteam in den develop-Branch überführt. Bei jedem Push werden per Gitlab Pipeline Unittests im Front- und Backend ausgeführt. Im Backend habe ich die bestehenden Unittests erweitert um neu implementierte Logik zu testen. Zu dem wurde im Frontend ein \gls{Linter} konfiguriert um einheitliche Codeguidelines und Codestyling durchzusetzen.\\
Wenn eine Änderung auf den Developbranch gepusht wurde wird diese von einem anderen Entwickler getestet. Außerdem gibt es weitere Mitarbeiter außerhalb des Entwicklerteams die regelmäßig auf dem Testsystem Blackbox-Akzeptanztests durchführen.