\section{Entwurfsphase}
\label{entwurfsphase}
%Der \ac{OTR} ist schon lange in Entwurf und wurde 
\subsection{Zielplattform}
\label{zielplattform}
Das gesamte Projekt soll in einem \gls{Container} innerhalb eines \gls{k8s} Cluster laufen. Somit muss vorher ein Dockerimage gebaut werden um es dann in einem Container laufen zu lassen. Demnach ist die Zielplattform eine Linuxdistribution. Durch \gls{k8s} besteht ein Loadbalancing um eine bessere Skalierbarkeit zu ermöglichen. Ein Vorteil dieses Deployments ist zusätzlich, dass mehrere Versionen und unterschiedliche Stages die zeitgleich laufen vorhanden sind. Für jeden Feature-, Develop- und Masterbranch im Git wird jeweils eine eigene Instanz im \gls{k8s} Cluster erstellt, so dass jeder Stand auf dem Entwicklungssystem getestet werden kann. Dadurch ist die Anwendung besser testbar und neue Versionen können nahtlos veröffentlicht werden.\footnote{s.\cite{GitlabKubernetes2021} Using a GitLab CI/CD workflow for Kubernetes}
\subsection{Architekturdesign}
\label{architekturdesign}
Die Backend Architektur besteht aus Microservices nach dem \gls{ddd}-Pattern. Außerdem wird für die Datenpersistenz das \gls{repopattern} benutzt. Im Frontend werden Komponenten verwendet, welche ihre Daten über eine zentrale Datenzustandsverwaltung beziehen. Die Kommunikation zwischen Front- und Backend wird durch REST-API Aufrufe realisiert. Um die Daten synchron zu halten wird jede Änderung im Frontend in den \gls{localstorage} des Browsers geschrieben und zeitgleich per \gls{HTTP}-\gls{jsonpatch} Aufruf an das Backend weitergesendet. Das Backend speichert die neuen oder geänderten Daten im Cache und führt, wenn möglich, eine Berechnung sowie Validierung durch. Die berechneten Beiträge und Validierungsergebnisse werden anschließend zurückgesendet. Durch die generische \gls{jsonpatch} Methode können Änderungen auch kleinteilig in Form von Schlüssel-Wert-Paaren bestehend aus dem Pfad in der JSON Struktur und dem Wert zwischen Front- und Backend synchronisiert und über das Backend persistiert werden. Das Persistieren über das \gls{repopattern} wird eingehender in Abschnitt \ref{datenmodell} \nameref{datenmodell} erklärt.
\subsection{Entwurf der Benutzeroberfläche}
\label{benutzeroberfläche}
Der designseitige Entwurf der Benutzeroberfläche wurde durch die Marketing-Abteilung per Mockups übernommen. Diese mussten allerdings nicht eins zu eins umgesetzt werden, sondern konnten in Kombination mit den \gls{corpdes}-Vorlagen als Richtlinie genutzt werden. Weiterhin gab es wöchentliche Absprachen in denen speziell das Design abgestimmt wurde. Dadurch musste weniger Zeit für die Entwicklung und Entwerfen der Oberfläche und Workflows von meiner Seite aus aufgebracht werden. Abbildungen eines Mockups, das finale Design der Fußzeilenkomponente und die Fußzeile im Gesamtkontext des \ac{OTR} sind jeweils im Anhang zu finden (s. \ref{uisection} \nameref{mockup}, \ref{uisection} \nameref{actualfooter}, \ref{uisection} \nameref{otr_figure})
\subsection{Entwurf der Datenstruktur}
\label{datenmodell}
Wie schon in \ref{architekturdesign} \nameref{architekturdesign} erwähnt, wird das \gls{repopattern} angewendet um Daten zu persistieren. Dementsprechend gibt es verschiedene Repository-Klassen, welche den Datenzugriff kapseln. Der Datenzugriff ist hierbei zweistufig. Als erstes werden gespeicherte Angebote, Tarifkonfiguration oder andere übergebene Daten im Cache gespeichert. Dieser ist nur ein temporärer Speicher der die Daten für bis zu sechs Stunden im Arbeitsspeicher hält. Die zweite Stufe ist der \gls{distributedcache} (Storage). Der Storage speichert die Daten in einer Datenbank ab.
Wenn, wie in \ref{projektschnittstellen} \nameref{projektschnittstellen} dargestellt, Angebote über das Maklerportal gespeichert werden, werden die Daten fünf Jahre lang in der Datenbank persistiert. Eine andere Möglichkeit um Daten vom Cache in den Storage zu überführen ist der Aufruf der Shutdown-Action im Backend. Dabei werden die Daten einen Tag lang gespeichert. Benutzt wird Shutdown z.B. wenn der \ac{OTR} neugestartet werden muss und die Daten dementsprechend aus dem Cache kurzzeitig gespeichert werden müssen damit diese nicht verloren gehen.\\
Bei einem Datenzugriff wird immer als erstes der Cache abgefragt und wenn die geforderten Daten dort nicht zu finden sind, der Storage.\footnote{s.\cite{CacheNet2022} Cache in-memory in ASP.NET Core}\footnote{s.\cite{Verteilter-Cache2021} Verteilter Cache}\\
Für die Zustandsverwaltung der Daten im Frontend wird der \gls{pinia} benutzt. Dieser ist typsicher, wodurch das Arbeiten mit Typescript erleichtert wird. Allgemein können mit so einem Store die Daten komponentenübergreifend einheitlich gespeichert werden. In dem Frontend des \ac{OTR} werden in dem \gls{pinia} wichtige Daten, welche das Backend bei der Initialisierung liefert, gespeichert. Dazu gehören unter anderem Konfigurationen, wie die Oberfläche des \ac{OTR}s aufgebaut werden soll, welche Eingabemöglichkeiten gegeben sind und eventuelle Sitzungsdaten, wenn eine bestehende Sitzung geladen wurde. Außerdem werden berechnete Beiträge sowie eingegebene Daten gespeichert. Der Zugriff auf die Daten aus anderen Komponenten erfolgt über Gettermethoden, welche im Store definiert werden.
\subsection{Entwurf der Geschäftslogik}
\label{geschaeftslogik}
Die Logik der Benutzeroberfläche und die technische Umsetzung wurden innerhalb des Entwicklerteams durch Prototyping erarbeitet. \footnote{s.\cite{Prototyping2022} Software Prototyping, Wikipedia}
Dadurch musste für die Fußzeilenkomponente speziell kein eigener Entwurf entstehen, es wurde anhand des Entwurfs für das Gesamtprojekt bearbeitet.\\
Wie schon in \ref{projektziel} \nameref{projektziel} beschrieben, wird die Oberfläche unter anderem mit \gls{vue} realisiert. Der große Vorteil von \gls{vue} ist, dass die Oberfläche reaktiv gemacht wird. Somit ändert sich das Oberflächenelement automatisch, wenn sich die zugehörigen Daten ändern. Dies geschieht über das Observer-Designpattern.\\ \footnote{Vgl.\cite{ReactivityinDepth2022} Reactivity in Depth}
Für den \ac{OTR} wichtige Daten werden in dem Store gespeichert. Die Fußzeilenkomponente greift hierbei auf die Konfiguration des \ac{OTR}s sowie die Sessionguid zu.
Eine weitere Funktion des Stores ist ein Benachrichtigungssystem. Hierbei wird bei jeder Änderung von bestimmten Daten ein Ereignis ausgelöst, so dass eine Benachrichtigung, z.B. ein Fehler oder eine Erfolgsnachricht bei einer Aktion, ausgegeben wird.\\

Die Geschäftslogik bzw. das Backend ist eine \gls{net} \gls{api}. Als Programmiersprache wird dementsprechend C\# 10 benutzt.
Im Backend werden Datenhalterklassen anhand von \gls{xml} Schemata automatisch generiert. Mit Hilfe von der Swagger OpenApi Dokumentation der Controller wird ein \gls{typescript} API-Client geschaffen. Genauso werden C\#-Clients für benutzte Schnittstellen, z.B. dem Dokumentenversandservice, erzeugt.\\
Für die einzelnen Controller der API bestehen Serviceklassen in welchen die Funktionalität bereitgestellt wird. So gibt es ein Interface welches die benötigten Methoden vorgibt und eine abstrakte Klasse welche alle tarifunabhängigen Methoden des Interfaces implementiert. Zudem gibt es für jeden Tarif oder jedes Versicherungsprodukt eine Klasse, welche von der abstrakten Klasse erbt und das Interface implementiert. Dadurch kann im Controller dynamisch anhand vom jeweilig aktivem Tarif die passende Implementierung benutzt werden. %todo management service klassendiagramm zeige
Alle Abhängigkeiten werden per \gls{di} aufgelöst.
\subsection{Maßnahmen zur Qualitätssicherung}
\label{qualitaetssicherung}
Durch die Arbeit mit \gls{gitflow} wurde jede Unteraufgabe in einem eigenem Gitbranch bearbeitet. Diese Branches werden erst nach Codereviews vom Entwicklerteam in den \textit{develop}-Branch überführt. Bei jedem Push werden per Gitlab Pipeline Unittests im Front- und Backend ausgeführt. Im Backend wurden die bestehenden Unittests erweitert um neu implementierte Logik zu testen. Zudem wurde im Frontend ein \gls{Linter} konfiguriert um einheitliche Codeguidelines und Codestyling durchzusetzen.\\
Wenn eine Änderung auf den Developbranch gepusht wurde wird diese von einem anderen Entwickler getestet. Außerdem gibt es weitere Mitarbeiter außerhalb des Entwicklerteams die regelmäßig auf dem Testsystem Blackbox-Akzeptanztests durchführen.